package ba.unsa.etf.rpr.Business;

import ba.unsa.etf.rpr.business.ExhibitionManager;
import ba.unsa.etf.rpr.dao.DaoFactory;
import ba.unsa.etf.rpr.dao.ExhibitionsSQLImplementation;
import ba.unsa.etf.rpr.domain.Exhibitions;
import org.apache.commons.lang3.RandomStringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import java.sql.Date;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.mockito.Mockito.when;

public class ExhibitionsManagerTest {
    private ExhibitionManager exhibitionsManager;
    private Exhibitions e;
    private ExhibitionsSQLImplementation exhibitionsSql;
    private List<Exhibitions> exhibitions;


    @BeforeEach
    public void initialize(){
       exhibitionsManager= new ExhibitionManager();
        Mockito.mock(ExhibitionManager.class);
        e = new Exhibitions();

        e.setExhibition_name("Early work of da Vinci");
        e.setStart_date(Date.valueOf(LocalDate.now()));
       // e.setEnd_date(21.4.2023.);
        e.setLocation("London");

        exhibitionsSql = Mockito.mock(ExhibitionsSQLImplementation.class);
        exhibitions = new ArrayList<>();
      //  exhibitions.addAll(Arrays.asList(new Exhibitions(50,"Painter's Golden Age", Date.valueOf(LocalDate.now()),"5.6.2023","Paris"));

    }
 /*   @Test
    void validName() {

        String n1 = "Zana";
        String n2 = "Jack";
        try {
            employeeManager.validname(n1);
            employeeManager.validname(n2);
        } catch (EmployeeException e) {
            e.printStackTrace();
            Assertions.assertTrue(false);
        }
        String incorrectn = "A";
        Assertions.assertThrows(EmployeeException.class, () -> {
            employeeManager.validname(incorrectn);
        }, "Name of employee must be between 2 and 45 chars");
        String inc = RandomStringUtils.randomAlphabetic(50);
        Assertions.assertThrows(EmployeeException.class, () -> {
            employeeManager.validname(inc);
        }, "Name of employee must be between 2 and 45 chars");

    }
    @Test
    void add() throws EmployeeException{
        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDAOSQL);
        when(DaoFactory.employeeDao().getAll()).thenReturn(employees);
        employeeManager.add(e);
        EmployeeException emp=Assertions.assertThrows(EmployeeException.class, ()->{
            employeeManager.add(e);}, "ID is autogenerated. Cannot add department.");
        Assertions.assertEquals("ID is autogenerated. Cannot add department.", emp.getMessage());
        daoFactoryMockedStatic.verify(DaoFactory::employeeDao);
        Mockito.verify(employeeManager).add(e);
        daoFactoryMockedStatic.close();
    }
    @Test
    void addNewEmp() throws EmployeeException{
        Employee e=new Employee(55,"Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
        e.setId(0);

        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);

        EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);

        when(employeeDao.add(e)).thenReturn(e);

        employeeManager.add(e);
        Assertions.assertTrue(true);
    }
    @Test
    void UpdateEmp() throws  EmployeeException{
        Employee e=new Employee(55,"Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
        e.setId(0);
        e.setEdu("Master");
        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
        EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);

        when(employeeDao.update(e)).thenReturn(e);

        employeeManager.update(e);
        Assertions.assertTrue(true);
    }
    @Test
    void DeleteEmp() throws EmployeeException{
        Employee e=new Employee(55,"Zina","Marrs","street278.D",LocalDate.now(),new Departments(10),new Project(201),"Bachelor",1000);
        e.setId(0);
        e.setEdu("Master");
        MockedStatic<DaoFactory> daoFactoryMockedStatic=Mockito.mockStatic(DaoFactory.class);
        EmployeeDAOSQLImpl employeeDao=Mockito.mock(EmployeeDAOSQLImpl.class);
        daoFactoryMockedStatic.when(DaoFactory::employeeDao).thenReturn(employeeDao);

        // when(employeeDao.delete(e.getId())).thenReturn(e);

        employeeManager.delete(e.getId());
        Assertions.assertTrue(true);
*/
    }